
\documentclass[a4paper,12pt]{article}
\usepackage{times}
\usepackage[francais]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{pdflscape}
\usepackage{listings}
\usepackage{longtable}
\lstset{literate=
{é}{{\'e}}1
{è}{{\`e}}1
{ê}{{\^e}}1
{à}{{\`a}}1
{â}{{\^a}}1
}
\lstset{language=C++,
basicstyle=\footnotesize,
keywordstyle=\footnotesize\color{blue},
otherkeywords={override,nullptr}
}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}
\lstdefinelanguage{JSON}
{
basicstyle=\normalsize,
columns=fullflexible,
showstringspaces=false,
commentstyle=\color{gray}\upshape,
morestring=[b]",
morestring=[s]{>}{<},
morecomment=[s]{<?}{?>},
stringstyle=\color{orange},
identifierstyle=\color{darkblue},
keywordstyle=\color{blue},
morekeywords={string,number,array,object}% list your attributes here
}

\sloppy

\setlength{\topmargin}{0cm}
\setlength{\headsep}{0.in}
\setlength{\headheight}{0.in}
\setlength{\evensidemargin}{0cm}
\setlength{\oddsidemargin}{-1cm}
\textwidth 18cm
\textheight 25cm

\begin{document}

    \thispagestyle{empty}

    \begin{titlepage}

        \vspace*{2cm}

        \begin{center}\textbf{\Huge Projet Logiciel Transversal}\end{center}{\Large \par}

        \begin{center}\textbf{\large Anand Candassamy \& Paul Estano}\end{center}{\large \par}

        \vspace{2cm}

        \clearpage

        {\small
        \tableofcontents
        }

    \end{titlepage}

    \clearpage
    \section{Présentation Générale}

    \subsection{Archétype}
	    Notre jeu s'inspirera principalement du jeu \emph{Pokemon Donjon Mystère}. En effet, nous avons prévu de conserver le mécanisme des combats et de donjon de ce jeu.
	    \\Dans notre logiciel l'utilisateur incarnera un pokemon dans les salles d'un donjon qui contiennent chacune des pokemons qui peuvent l'"agresser". Le nombre de pokemons dans une salle évolue en fonction de l'avancement du joueur dans le jeu.
	    \\Pour simplifier le jeu nous abandonnons également d'évolution des pokemons.

    \subsection{Règles du jeu}
	  Le donjon contient un nombre fini de salles et le joueur gagne lorsqu'il sort de la dernière salle du donjon.
	  Un donjon a 10 salles, le pattern de chaque étage n'est pas tiré aléatoirement. Le joueur a la possibilité d'accéder à des étages bonus, dîtes arène de combat où il pourra se battre contre un autre joueur en ligne.
	   \\Le joueur est provoqué en duel automatiquement par les pokemons qui sont autour de lui.
\\Les combats fonctionnent en tour par tour. A chaque tour, l'utilisateur peut effectuer qu’une seule action :
\begin{itemize}
    \item attaquer avec une compétence
    \item soigner le pokemon
    \item se déplacer
\end{itemize}
\clearpage
    \subsection{Ressources}
    \begin{figure}[ht]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{tilemap.png}
    \end{center}
    \caption{Tileset utilisé pour construire un monde}
    \end{figure}
    
    \begin{figure}[ht]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{pokemonLatex.png}
    \end{center}
    \caption{Tileset utilisé pour les pokémons}
    \end{figure}



    \clearpage
    \section{Description et conception des états}
    
    \subsection{Description des états}
    Un état du jeu est formé d'une carte qui est statique au cours du temps et d'une liste de joueurs dont l'état varie au cours du jeu.
    
     \subsubsection{État de la carte}
     
     La carte est un élément fixe de l'état du jeu. Il se décompose en plusieurs cases.
    
     Les cases se distinguent en 3 parties : \begin{itemize}
    \item les murs, qui ne sont pas franchissables par les éléments mobiles.
    \item les cases "conteneurs", elles peuvent être vide ou occupé par un seul élément mobile.
    \item les cases escaliers, il en existe un seul par étage, qui permet d'aller au niveau suivant du labyrinthe.
    
    \end{itemize}

    \subsubsection{État des joueurs}
    Un pokemon est soit contrôlé par un joueur soit contrôlé par une Intelligence Artificielle (I.A), il possède une position, un nombre de points de vie à l'état t, un nom et un ensemble de statistiques qui lui sont attribués en début de partie. Le pokemon est considéré comme étant "mort" si son nombre de points de vie atteint 0.
    
    \subsubsection{État général}
    A l’ensemble des éléments statiques et mobiles, nous rajoutons les propriétés suivantes :
    — Époque : représente « l’heure » correspondant à l’état, ie c’est le nombre de « tour » passés
    globale depuis le depuis de la partie.

    
    Ces statistiques correspondent aux attaques qu'il peut utiliser, à son nombre de point de vie en début de partie et son type (eau, feu, herbe).
    \subsection{Conception Logiciel}
    Le package état peut se diviser en trois sous-partie:\begin{itemize}
        \item Une partie gérant les personnages, en bleu
        \item Une partie gérant l'environnement, en rouge
        \item Une classe représentant l'état global du jeu, en vert
    \end{itemize}
    
     La classe \emph{player} contient l'ensemble des éléments permettant de caractériser l'état d'un joueur. Chaque joueur est lié à un pokemon par une relation de composition : un pokemon ne peut pas exister sans joueur. Dans le cas où le pokemon est contrôlé par l'IA, l'IA est considérée comme un joueur et contrôle donc son pokemon.
    
    Chaque pokemon possède une relation d'agrégation avec des statistiques qui lui sont attribués en début de partie.
    
    Pour notre implémentation du jeu, nous avons prévu d'utiliser que les trois pokémon suivant : \begin{itemize}
        \item Carapuce
        \item Salamèche
        \item Bulbizarre
    \end{itemize}
    Le constructeur respectif de chacun de ces trois pokemons héritent de la classe Pokemon. Nous avons mis en place un identifiant pour chaque pokemon, ce qui permet d'avoir plusieurs pokemon construit à partir de la même classe.
    
    La partie environnement est calqué sur le modèle proposé par les fichiers exportés par le logiciel \emph{Tiled Map Editor}. Les objets les plus consommateurs en mémoire tels les \emph{data} dans la classe \emph{Layer} sont par ailleurs stockés dans le tas pour éviter les copies entre les différentes classes.
    
     L'état global contient un pointeur vers l'état de l'environnement et et une liste de pointeur de contenant l'état des différents joueurs de la partie.
     
     Afin d'éviter des problèmes techniques suite à notre implémentation, nous avons mis en place des fonctions afin de capturer les exceptions rencontrées lors de l'exécution, principalement dans la classe qui charge les données de la carte. De plus nous avons utilisés des entiers signé afin que les valeurs et statistiques des pokemons ne prennent jamais de valeurs négatives.
     
     Nous avons pour l'instant implémenter que les fonction set et get qui permettent d'instancier nos objets liés aux états . 
    \begin{landscape}
    \begin{figure}[p]
    \includegraphics[width=0.8\paperheight]{state.png}
    \caption{\label{uml:state}Diagramme des classes d'état.}
    \end{figure}
    \end{landscape}
    \clearpage
    
    
    \section{Rendu: Stratégie et Conception}

    \subsection{Stratégie de rendu d'un état}
    
Notre stratégie de rendu d'un état se base sur l'utilisation de l'interface SFML qui s'appuie sur OpenGL afin de générer un rendu en 2D. Nous avons utiliser les fonctions de SFML afin de charger dans le processeur, la liste des éléments à afficher par le processeur graphique. 
    
Nous avons découper notre affichage graphique sur deux niveaux, la carte avec les éléments décoratifs (mur, sol, escalier) et les éléments mobiles à savoir les pokemons (Carapuce, Salamèche, Bulbizarre) qui se superpose sur le claque précédent. On transmet l'état du jeu ainsi que les textures de toute la carte avec leurs coordonnées et la texture des pokemons avec leurs coordonnées et leur orientation à afficher.
        
La carte étant très grande, nous avons entièrement chargé dans la mémoire pour l'affichage et on a crée une vue (un zoom) centrée sur le pokemon du joueur qui évolue sur la carte, car le but du jeu reste avant tout d'évoluer dans un labyrinthe.
     
Lorsque qu'un changement d'état se produit, nous regardons si le rendu doit être modifié, dans ce cas là, nous mettons à jour la vue et l'état des éléments mobiles. 
        
Pour simplifier au mieux notre logiciel, nous n'avons pas inclut les animations de déplacements lorsque le pokemon évolue d'une case à l'autre ainsi que les animations d'attaques quand un pokémon lance une compétence sur un autre.


    \subsection{Conception logiciel}
Pour afficher un état on crée une scène qui génère instancie un ensemble de pointeurs sur des objets graphiques de types \emph{LayerRender} pour la carte et \emph{PokerRender} pour les pokemons. Puis, on utilise la méthode \emph{Scene::draw()} pour déclencher l'ouverture de la fenêtre et l'affichage de l'état.
Lorsqu'un changement d'état survient on peut mettre à jour les objets graphiques sans interrompre l'affichage grâce à la méthode \emph{Scene::updateState()}. Cette méthode n'est utilisable que si les ressources graphiques de la carte ne changent pas. Si l'on veut utiliser de nouvelles ressources graphiques pour afficher la carte, il est nécessaire de réinstancier une scène (ce qui fermera la fenêtre).

Chaque objet \emph{LayerRender} parcourt l'ensemble des tuiles d'un étage de la carte, détecte la position de la tuile sur la ressource graphique (i.e : l'image du tileset) et calcule sa position sur la fenêtre. Pour optimiser les performances seule l'image du tileset est chargée dans une \emph{Texture}, l'objet \emph{LayerRender} conserve seulement la position de chaque tuile de la carte sur cette texture.
L'objet \emph{PokeRender}fait des opérations identiques pour cette fois ci un seul objet : le pokemon désiré.

    \begin{landscape}
    \begin{figure}[p]
    \includegraphics[width=0.9\paperheight]{render.png}
    \caption{\label{uml:render}Diagramme des classes de rendu.}
    \end{figure}
    \end{landscape}

    \clearpage
    \section{Règles de changement d'états et moteur de jeu}

    \subsection{Règles}

    \clearpage
    \subsection{Conception logiciel}


    %\begin{landscape}
    %\begin{figure}[p]
    %\includegraphics[width=0.9\paperheight]{engine.pdf}
    %\caption{\label{uml:engine}Diagramme des classes de moteur de jeu.}
    %\end{figure}
    %\end{landscape}


    \section{Intelligence Artificielle}

    \subsection{Stratégies}

    \clearpage
    \subsection{Conception logiciel}


    %\begin{landscape}
    %\begin{figure}[p]
    %\includegraphics[width=0.9\paperheight]{ai.pdf}
    %\caption{\label{uml:ai}Diagramme des classes d'intelligence artificielle.}
    %\end{figure}
    %\end{landscape}


    \section{Modularisation}
    \label{sec:module}

    \subsection{Organisation des modules}

    \clearpage
    \subsection{Conception logiciel}
    
    \clearpage
    \section{Annexe}
    \label{sec:Annexe}
    \subsection{Bibliographie}

    %
    %\begin{landscape}
    %\begin{figure}[p]
    %\includegraphics[width=0.9\paperheight]{module.pdf}
    %\caption{\label{uml:module}Diagramme des classes pour la modularisation.}
    %\end{figure}
    %\end{landscape}

\end{document}
